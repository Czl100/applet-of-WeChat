# 接口文档
下文中的host代表HTTP服务器，开发环境下采用本地服务器，生产环境下采用远程服务器。<br>
远程服务器 `#define host https://crp`，这里的crp为域名，解析到`111.230.92.161`。<br>
本地服务器 `#define host http://localhost:5000`

## 一、登陆与退出
应该在App的onShow()事件中进行会话建立，在App的onHide()事件中进行会话销毁。<br>
通过wx.login取得临时凭证再到服务器进行注册，并取得sessionId。sessionId作为小程序和服务器的会话凭证，服务器会将sessionId和wxId绑定在一起。<br>
```
发送会话建立请求:
{
    url:host/sessionBuild/<code>,   # <code> 微信凭证
    method:get,
    data:{
    }
}
JSON返回值:
{
    "fg" : True/False,          # 建立会话是否成功的标志
    "msg": <msg>,               # 错误时附带的信息
    "sessionId":<sessionId>     # sessionId，应该进行缓存，后续的所有请求都应该附带sessionId
}
```
当微信小程序进入后台时将会触发onHide()事件，在该事件中将会销毁会话。服务器接收到会话销毁时，就算服务器返回销毁失败，服务器也应该继续销毁。
```
发送会话销毁请求:
{
    url:host/sessionDestroy,
    method:get,
    data:{
        sessionId:<sessionId>
    }
}
JSON返回值:
{
    "fg" : True/False,          # 销毁会话是否成功的标志，服务器应该确保小程序退出时，必须销毁会话。
    "msg": <msg>,               # 错误时附带的信息
}
```

## 二、图像绑定与查询
图像绑定
```
发送图像绑定请求：
{
    url:host/image-bind,
    method:post,
    data:{
        sessionId : <sessionId>,        # sessionId
        img : <imgFile>                 # 上传图像
    }
}
JSON返回值:
{
    "fg":True/False,            # 绑定是否成功的标志
    "msg":<msg>,                # 错误时附带的信息
}
```
作者溯源
```
发送作者溯源请求：
{
    url:host/author-query,
    method:post,
    data:{
        sessionId : <sessionId>,        # sessionId
        file : <file>,                  # 文件路径
    }
}
JSON返回值:
{
    "fg":True/False,            # 溯源是否成功的标志(没有找到作者，也会返回False)
    "msg":<msg>,                # 溯源没有成功的附带信息
    "title":<title>,            # 图片名称
    "imgId":<imgId>             # 图像Id，用以和图像作者建立联系
}
```

## 三、不可见信息的嵌入和提取
嵌入不可见信息
```
发送嵌入请求:
{
    url:host/ih
    method:post,
    data:{
        sessionId:<sessionId>,
        file:<file>,
        key:<md5-key>,          # key的md5值
        secret:<secret>         # 密文信息
    }
}
JSON返回值:
{
    "fg":True/False,            # 嵌入是否成功的标志
    "msg":<msg>,                # 嵌入失败的附带信息
}
```
提取不可见信息
```
发送提取请求:
{
    url:host/ix,
    method:post,
    data:{
        sessionId:<sessionId>,
        file:<file>,
        key:<md5-key>
    }
}
JSON返回值:
{
    "fg":True/False,
    "msg":<msg>,
    "secret":<secret>
}
```
## 四、历史信息
查询历史消息
```
发送查询历史信息请求:
{
    url:host/histroy,
    method:get,
    data:{
        sessionId:<sessionId>,      # 会话ID
        page:<page>                 # 查询的页数，第一次查询就应该查询第一页
    }
}
JSON返回值:
{
    "fg":True/False,            # 历史记录查询是否成功
    "msg":<msg>,                # 查询失败的原因
    "lists":[                   # 消息记录列表
        {
            "img":<img-url>,        # 图片URL，若图像未处理完成，返回"None"
            "title":<title>,        # 图片标题
            "date":<date>           # 图片操作时间
        },
        ...
    ],
    "pages":<page-number>       # 总页数
}
```

## 五、邀请与提醒
发送邀请
```
发送邀请请求:
{
    url:host/invite,
    method:post,
    data:{
        sessionId:<sessionId>,
        imgId:<imgId>,          # 图像Id, 邀请的就是和图像Id所绑定的作者
        text:<text>             # 邀请作者的文本，不得超过140个字，前端后台都应该做限制
    }
}
JSON返回值:
{
    "fg":True/False,            # 发送邀请是否成功
    "msg":<msg>                 # 发送失败的附带信息
}
```
查询未读邀请个数。未读邀请的个数应该显示在主页上，应该由小程序周期轮询，一旦有新的未读应该更新到主面上。
```
查询未读邀请个数:
{
    url:host/unread-number,
    method:get,
    data:{
        sessionId:<sessionId>
    }
}
JSON返回
{
    "fg":True/False,            # 查询是否成功
    "msg":<msg>,                # 查询失败时的附带信息
    "number":<unread-number>    # 未读邀请个数
}
```
查询邀请
```
发送查询邀请请求
{
    url:host/invite-query,
    method:get,
    data:{
        sessionId:<sessionId>,
        page:<page>             # 查询的页数
    }
}
JSON返回
{
    "fg": True/False,           # 查询是否成功
    "msg":<msg>,                # 查询失败的附带信息
    "invites":[
        {
            inviter:<inviter>,      # 邀请者称呼
            imgTitle:<img-title>,   # 图片标题
            img:<img-url>,          # 图片URL
            text:<text>             # 消息提醒内容
        },
        ...
    ],
    "pages":<page-number>       # 总页数
}
```